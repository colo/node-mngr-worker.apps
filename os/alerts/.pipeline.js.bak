var debug = require('debug')('pipeline:os-alerts');
var debug_internals = require('debug')('pipeline:os-alerts:Internals');

// var sanitize_filter = require(path.join(process.cwd(), '/etc/snippets/filter.sanitize.template')),

'use stric'

const path = require('path')

var cron = require('node-cron')


let expanded_alerts = require('./conf/expanded')

let condensed_alerts = require('./conf/condensed')

var alerts_payloads = {}

// let compress_filter =  require(path.join(process.cwd(), '/devel/etc/snippets/filter.zlib.compress')),
//     sanitize_filter = require(path.join(process.cwd(), '/devel/etc/snippets/filter.sanitize.template')),
let decompress_filter = require(path.join(process.cwd(), '/devel/etc/snippets/filter.zlib.decompress'))


module.exports = {
 input: [
  {
    poll: {
      id: "input.os.alerts.cradle",
      conn: [
        {
          scheme: 'cradle',
          host:'elk',
          //host:'127.0.0.1',
          port: 5984 ,
          db: 'live',
          module: require(path.join(process.cwd(), 'lib/pipeline/input/poller/poll/cradle')),
          load: ['apps/os/alerts/current']
        }
      ],
      requests: {
        /**
         * runnign at 20 secs intervals
         * needs 3 runs to start analyzing from last historical (or from begining)
         * it takes 60 secs to complete, so it makes historical each minute
         * @use node-cron to start on 0,20,40....or it would start messuring on a random timestamp
         * */
        // periodical: function(dispatch){
        // 	return cron.schedule('19,39,59 * * * * *', dispatch);//every 20 secs
        // }
        periodical: 1000,
        //periodical: 2000,//test
      },

    },
  },
  {
   poll: {
     id: "input.os.alerts.historical.cradle",
     conn: [
       {
         scheme: 'cradle',
         host:'elk',
         //host:'127.0.0.1',
         port: 5984 ,
         db: 'historical',
         module: require(path.join(process.cwd(), 'lib/pipeline/input/poller/poll/cradle')),
         load: ['apps/os/alerts/historical']
       }
     ],
     requests: {
       /**
        * runnign at 20 secs intervals
        * needs 3 runs to start analyzing from last historical (or from begining)
        * it takes 60 secs to complete, so it makes historical each minute
        * @use node-cron to start on 0,20,40....or it would start messuring on a random timestamp
        * */
       periodical: function(dispatch){
       	return cron.schedule('* * * * *', dispatch);
       }
       // periodical: 20000,
       //periodical: 2000,//test
     },

   },
  },
 ],
 filters: [
    // decompress_filter,
     /**
     * code taken from os.stats.vue
     **/
		function(doc, opts, next, pipeline){
      let extracted = {}
      debug_internals('%o', doc[0].doc.metadata)

      if(doc[0].doc && doc[0].doc.metadata.path.indexOf('historical') < 0 ){

      }
      else if(doc[0].doc && doc[0].doc.metadata){

      }






    },
    function(doc, opts, next, pipeline){
      //console.log('process_os_doc alerts filter', doc )

      let _alerts = {data: [], tabular: []}

      let parse_condensed_keys = function(condensed, value, alerts){

          let sub_key = condensed.substring(0, condensed.indexOf('.')).trim()
          condensed = condensed.replace(sub_key, '')

          // sub_key = sub_key.replace(/\/|_|-/g, '.')

          let rest_key = condensed.substring(condensed.indexOf('.')+1, condensed.length).trim()
          // rest_key = rest_key.replace('_', '.')

          // Array.each(arr_keys, function(arr_key, index){
          // console.log('sub_key', sub_key, rest_key)

          if(sub_key.length > 0){
            let sub_alert = undefined
            let recurse_alert = undefined

            if(sub_key.indexOf('[') > -1){
              sub_key = sub_key.replace(/\[|\]/g,'')
              // if(!alerts[sub_key])
                sub_alert = []
            }
            else{
              // if(!alerts[sub_key])
                sub_alert = {}
            }

            if(Array.isArray(alerts)){
              let tmp = {}
              tmp[sub_key] = sub_alert
              alerts.push( tmp )//change sub_key to array index
              recurse_alert = alerts[alerts.length - 1][sub_key]
            }
            else{

              if(!alerts[sub_key]){
                alerts[sub_key] = sub_alert
                // let tmp = {}
                // tmp[sub_key] = sub_alert

                // alerts[sub_key] = Object.merge(alerts[sub_key], sub_alert)
              }
              // else{
              //
              // }

              recurse_alert = alerts[sub_key]
            }

            // //console.log('rest_key', sub_key, rest_key, recurse_alert)

            parse_condensed_keys(rest_key, value, recurse_alert)
          }
          else {
            // throw new Error()
            if(Array.isArray(alerts)){
              let tmp = {}
              tmp[rest_key] = value
              alerts.push( tmp )
            }
            else{

              if(value.$payload){
                let new_payload

                if(value.$payload.$extra){

                  if(Array.isArray(value.$payload.$extra)){
                    new_payload = []

                    Array.each(value.$payload.$extra, function(extra, index){
                      let key = Object.keys(extra)[0]
                      new_payload[index] = {}
                      parse_condensed_keys(key, extra[key], new_payload[index])
                    })
                  }
                  else{
                    new_payload = {}
                    let key = Object.keys(value.$payload.$extra)[0]

                    parse_condensed_keys(key, value.$payload.$extra[key], new_payload)


                  }

                  // //console.log('NEW PAYLOAD', new_payload)

                  value.$payload.$extra = new_payload
                }
                else{
                  new_payload = {}
                  let key = Object.keys(value.$payload)[0]
                  new_payload = {}
                  parse_condensed_keys(key, value.$payload[key], new_payload)
                  value.$payload = new_payload
                }

                // //console.log('extras??', rest_key, value.$payload.$extra)

              }

              alerts[rest_key] = value

            }

          }

      }

      Object.each(condensed_alerts, function(alert, condensed){
        parse_condensed_keys(condensed, alert, _alerts)
      })

      let all_alerts = {data: [], tabular: []}
      all_alerts.data = all_alerts.data.append(expanded_alerts.data).append(_alerts.data)
      all_alerts.tabular = all_alerts.tabular.append(expanded_alerts.tabular).append(_alerts.tabular)
      // // Object.merge(expanded_alerts, _alerts)

      // console.log('ALL alerts', all_alerts.tabular[0]['%hosts'].os.loadavg['$payload'])
      // if(doc.tabular && doc.tabular.colo && doc.data.tabular.os && doc.data.tabular.os.procs)
        debug_internals('ALL alerts %O', doc.tabular)

      let original_doc = doc//needed to recurse $payload

      let recurse_alerts = function(alerts, doc, name){
        let result
        if(Array.isArray(alerts)){
          result = []
          Array.each(alerts, function(alert, index){
            result.push ( recurse_alerts(alert, doc, name) )
          })
        }
        else{//assume Object
          // let key = Object.keys(alerts)[0]

          Object.each(alerts, function(alert, key){

            if(key.indexOf('%') == 0){

                if(typeof alert == 'function'){
                  let payload = {
                    property: name,
                    next: next
                  }
                  result = alert.attempt([doc, payload])
                }
                else{
                  result = []
                  Object.each(doc, function(data, doc_key){
                    let sub_name = (name) ? name +'.'+doc_key : doc_key
                    result.push ( recurse_alerts(alert, data, sub_name) )
                  })
                }

            }
            else{

              if(
                doc[key]
                && (
                  typeof alert == 'function'
                  || (alert.$callback && typeof alert.$callback == 'function')
                )
              ){
                // //console.log('ALL alerts', key, alert)

                let fn
                if(alert.$callback){
                  fn = alert.$callback
                }
                else{
                  fn = alert
                }

                let payload = {
                  property: name+'.'+key,
                  next: next
                }

                if(alert.$payload){
                  // let value
                  if(alert.$payload.$extra){

                    if(Array.isArray(alert.$payload.$extra)){
                      alert.$payload.extra = []
                      Array.each(alert.$payload.$extra, function(extra, index){
                        alert.$payload.extra[index] = recurse_alerts(alert.$payload.$extra[index], original_doc, null)
                      })
                    }
                    else{
                      alert.$payload.extra = recurse_alerts(alert.$payload.$extra, original_doc, null)
                    }


                    payload = Object.clone(alert.$payload)
                    payload.property = name+'.'+key
                    // payload.opts = opts
                    payload.next = next
                    // payload.pipeline = pipeline
                    let alert_payload = {}

                    // if(Array.isArra(alert.$payload.$extra)){
                    //   Array.each(alert.$payload.$extra, function(extra, index){
                    //
                    //     if(alerts_payloads[fn.toString()+'.'+payload.property+'.'+index])
                    //       alert_payload = Object.clone(alerts_payloads[fn.toString()+'.'+payload.property+'.'+index])
                    //
                    //     Object.each(alert_payload, function(value, prop){
                    //       if(prop != 'extra' && prop != '$extra' && prop != 'property')
                    //         payload[prop] = value
                    //     })
                    //   })
                    // }
                    // else{

                      if(alerts_payloads[fn.toString()+'.'+payload.property])
                        alert_payload = Object.clone(alerts_payloads[fn.toString()+'.'+payload.property])

                      Object.each(alert_payload, function(value, prop){
                        if(prop != 'extra' && prop != '$extra' && prop != 'property')
                          payload[prop] = value
                      })
                    // }




                  }
                  else{
                    payload['extra'] = recurse_alerts(alert.$payload, original_doc, null)
                  }



                  // value = recurse_alerts(alert.$payload, original_doc, null)
                  // //console.log('alert.$payload', alerts_payloads)
                  // payload['extra'] = value
                }
                // else{
                //   payload.property = name+'.'+key
                // }

                result = fn.attempt([doc[key], payload])

                if(alert.$payload && alert.$payload.$extra){
                  alerts_payloads[fn.toString()+'.'+payload.property] = Object.clone(payload)
                }

              }
              else if (doc[key]) {
                let sub_name = (name) ? name+'.'+key : key
                result = recurse_alerts(alerts[key], doc[key], sub_name)
              }
            }

          })

        }


        return result
      }

      recurse_alerts(all_alerts, doc, null)
      // recurse_alerts(expanded_alerts, doc, null)
      // recurse_alerts(_alerts, doc, null)
    },
    // require(path.join(process.cwd(), '/etc/snippets/filter.sanitize.template')),

	],
	output: [
    // function(doc){
    //   //console.log('os alerts output',JSON.decode(doc))
    // },
    //require('./snippets/output.stdout.template'),
    // {
    // 	cradle: {
    // 		id: "output.os.alerts.cradle",
    // 		conn: [
    // 			{
    // 				//host: '127.0.0.1',
    // 				host: 'elk',
    // 				port: 5984,
    // 				db: 'dashboard',
    // 				opts: {
    // 					cache: true,
    // 					raw: false,
    // 					forceSave: true,
    // 				}
    // 			},
    // 		],
    // 		module: require(path.join(process.cwd(), 'lib/pipeline/output/cradle')),
    // 		buffer:{
    // 			size: 0,
    // 			expire:0
    // 		}
    // 	}
    // }

    // {
		// 	couchdb: {
		// 		id: "output.os.couchdb",
		// 		conn: [
		// 			{
    //         scheme: 'http',
		// 				host: 'elk',
		// 				port: 5984,
		// 				db: 'alerts',
		// 				opts: {
		// 				},
		// 			},
		// 		],
		// 		module: require(path.join(process.cwd(), 'lib/pipeline/output/couchdb')),
    //     buffer:{
		// 			size: 0,
		// 			expire:0
		// 		}
		// 	}
		// }
  ]
}
